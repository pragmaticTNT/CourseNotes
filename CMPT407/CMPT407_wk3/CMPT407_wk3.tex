%
% This is a borrowed LaTeX template file for lecture notes for CS267,
% Applications of Parallel Computing, UCBerkeley EECS Department.
% Now being used for CMU's 10725 Fall 2012 Optimization course
% taught by Geoff Gordon and Ryan Tibshirani.  When preparing 
% LaTeX notes for this class, please use this template.
%
% To familiarize yourself with this template, the body contains
% some examples of its use.  Look them over.  Then you can
% run LaTeX on this file.  After you have LaTeXed this file then
% you can look over the result either by printing it out with
% dvips or using xdvi. "pdflatex template.tex" should also work.
%

\documentclass[twoside]{article}
\setlength{\oddsidemargin}{0.25 in}
\setlength{\evensidemargin}{-0.25 in}
\setlength{\topmargin}{-0.6 in}
\setlength{\textwidth}{6.5 in}
\setlength{\textheight}{8.5 in}
\setlength{\headsep}{0.75 in}
\setlength{\parindent}{0 in}
\setlength{\parskip}{0.1 in}

%
% ADD PACKAGES here:
%

\usepackage{amsmath,amsfonts,amssymb, graphicx}
\usepackage{color}
\usepackage{comment}
\usepackage{mathtools}

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}

%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[4]{
   \pagestyle{myheadings}
   \thispagestyle{plain}
   \newpage
   \setcounter{lecnum}{#1}
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CMPT 407: Computational Complexity
	\hfill Summer 2017} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill Lecture #1: #2  \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Lecturer: #3 \hfill Scribe: #4} }
      \vspace{2mm}}
   }
   \end{center}
   \markboth{Lecture #1: #2}{Lecture #1: #2}

   %{\bf Note}: {\it LaTeX template courtesy of UC Berkeley EECS dept.}

   %{\bf Disclaimer}: {\it These notes have not been subjected to the
   %usual scrutiny reserved for formal publications.  They may be distributed
   %outside this class only with the permission of the Instructor.}
   \vspace*{4mm}
}
%
% Convention for citations is authors' initials followed by the year.
% For example, to cite a paper by Leighton and Maggs you would type
% \cite{LM89}, and to cite a paper by Strassen you would type \cite{S69}.
% (To avoid bibliography problems, for now we redefine the \cite command.)
% Also commands that create a suitable format for the reference list.
%\renewcommand{\citep{â€¢}ite}[1]{[#1]}
\def\beginrefs{\begin{list}%
        {[\arabic{equation}]}{\usecounter{equation}
         \setlength{\leftmargin}{2.0truecm}\setlength{\labelsep}{0.4truecm}%
         \setlength{\labelwidth}{1.6truecm}}}
\def\endrefs{\end{list}}
\def\bibentry#1{\item[\hbox{[#1]}]}

%Use this command for a figure; it puts a figure in wherever you want it.
%usage: \fig{NUMBER}{SPACE-IN-INCHES}{CAPTION}
\newcommand{\fig}[3]{
			\vspace{#2}
			\begin{center}
			Figure \thelecnum.#1:~#3
			\end{center}
	}
% Use these for theorems, lemmas, proofs, etc.
\newtheorem{theorem}{Theorem}[lecnum]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{2mm}{2mm}}

% **** IF YOU WANT TO DEFINE ADDITIONAL MACROS FOR YOURSELF, PUT THEM HERE:

\newcommand\E{\mathbb{E}}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\R{\mathbb{R}}
\def\C{\mathbb{C}}
\def\F{\mathbb{F}}
\def\P{\mathsf{P}}
\def\NP{\mathsf{NP}}
\def\coNP{\mathsf{coNP}}
\def\PH{\mathsf{PH}}
\def\EXP{\mathsf{EXP}}
\def\NEXP{\mathsf{NEXP}}
\def\Time{\mathsf{Time}}
\def\SAT{\mathsf{SAT}}
\def\SIZE{\mathsf{SIZE}}
\def\TAUT{\mathsf{TAUT}}
\def\NTime{\mathsf{NTime}}
\def\PSPACE{\mathsf{PSPACE}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\anglebrac{\langle}{\rangle}

\begin{document}
%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
\lecture{2}{Poly-time Hierarchy - 23~26 May}{Valentine Kabanets}{Lily Li}
%\footnotetext{These notes are partially based on those of Nigel Mansell.}

\section{Space Hierarchy}
Similar to the Time Hierarchy theorems, it simply states that with more time we can do more work. 

\begin{theorem}
For any $n \leq s \leq S \leq 2^n/n$ such that $S \geq 10 \cdot s$, we have
\[\SIZE (s) \subsetneq \SIZE (S)\]
\end{theorem}
\begin{proof}
First we will prove the following:
\begin{theorem}
(Shannon-Lupanov) For all sufficiently large $n$, the maximum circuit complexity of an $n$-variate Boolean function is
\[\frac{2^n}{n}\left( 1 + \Theta\left( \frac{\log n}{n}\right)\right)\]
\end{theorem}

\textcolor{red}{More of the proof to come...}
\end{proof}

We see this using a counting argument. Consider the total number of boolean formulas: there are $2^n$ possible clauses and each clause could be in the formula so there are $2^{2^n}$ boolean formulas. 	

\section{$\SAT$ Menagerie}
Consider different types of $\SAT$: 
\begin{enumerate}
\item Circuit $\SAT$ - these look like general digraph.
\item Formula $\SAT$ - these look like trees (only one output from each node).
\item CNF $\SAT$ - we have a CNF formula. 
\item $k-\SAT$ - each clause in the CNF has at most $k-\SAT$
\end{enumerate}

\begin{theorem}
All the above (including the last one with $k \geq 3$) are $\NP$-complete. 
\end{theorem}
\begin{proof}
We already showed that Circuit-$\SAT$ is $\NP$-complete. Next we will show that $3-\SAT$ is $\NP$-complete to complete the proof. It should be easy to see that $\SAT$ is in $\NP$. To show that $\SAT$ is $\NP$-hard reduce Circuit-$\SAT$ to $3-\SAT$. Take a circuit $C(x_1, ..., x_n)$ as an input. We want to make an instance of $3-\SAT$ associated with $C$. Let $\phi (x_1, ..., x_{n^d})$ be our $3-\SAT$ instance. Label the gates of $C$ as $g_1, ..., g_m$. Associate to each gate a set of $3$-CNF clauses. Then conjunct all the clauses (don't forget the output gate). Yay! You have created a valid $3-\SAT$ instance.    
\end{proof}

Consider the following trivial $\NP$-complete language:
\[L_u = \{ (M, x, 1^k): NTM M \mbox{ accepts } x \mbox{ in } \leq k \mbox{ steps}\}\]
\begin{proposition}
$L_u$ is $\NP$-complete.
\end{proposition}
\begin{proof}

\end{proof}

Once $\SAT$ was proved $\NP$-complete many more were proved to be $\NP$-complete as well. Such as $\mathsf{NAE-SAT}$ (not all equal $\SAT$) as follows: (omitting proof that $\mathsf{NAE-SAT} \in \NP$) 

Other language of interest is $\coNP$. Where languages in $\NP$ are those which have easy to verify $yes$ instances $\coNP$ have easy to verify $no$ instances. Not that $\NP$ and $\coNP$ are \emph{NOT} disjoint since $\P$ is in both. It is unknown if $\coNP = \NP$. 

\begin{proposition}
$\TAUT$ is $\coNP$-complete
\end{proposition}
\begin{proof}

\end{proof} 

\section{Nondeterministic Time Hierarchy}
Much like deterministic time hierarchy and space hierarchy, we need some way to say that with more time on a nondeterministic machine we can do more work. This is formalized in the following theorem. However, this time our standard diagonalization trick will not work because it is not know if $\NP = \coNP$.

\begin{theorem}
\textbf{$\NTime$ Hierarchy Theorem} For every proper complexity function $f(n) \geq n$ and $g(n) \in \omega(f(n+1))$, we have
\[\NTime (f(n)) \subsetneq \NTime (g(n))\]
\end{theorem} 
\begin{proof}
This is requires a different tool than diagonalization. The difficulty is due to the lack of closure for complementation in $\NP$ (not known if $\coNP = \NP$). Enumerate all NTM $M_1, M_2, ...$ which are clocked to run in less than $f(n)$ steps over the unary alphabet (this strengthens the theorem). Let $L(M_i)$ be the language of machine $M_i$. Let $t(n)$ be a fast growing function and split the natural numbers into intervals $[1, ..., t(n)], [t(n) + 1, ..., t^{(2)}(n)], ...$ indexed $I_1, I_2, ...$ where interval $I_i = [t^{i-1}(n) + 1, ..., t^{i}(n)]$ and $t^{k}(n)$ is the composition of $t(n)$, $k$ times. Define NTM $D$ which diagonalizes all $M_i$ as follows: give machine $M_i$ interval $i$ to work with for simplicity label this interval $[u_0, ..., u_m]$. The values of $D$ for $I_i$ is defined as: on input $1^{u_i}$ for $0 \leq i < m$, $D$ accepts if $M_i$ accepts $1^{u_{i+1}}$. On input $1^{u_m}$, $D$ accepts if $M_i$ rejects $1^{u_0}$.     
\end{proof}

\begin{proposition}
There exists a universal NTM $U$ which simulates a given NTM $M$ on input $x$ so that, if $M$ takes time $t$ on $x$, the the simulation by $U$ takes at most $c_M\cdot t$ time for some constant $c_M$. 
\end{proposition}

\section{Decision to Search}
Consider the difference between $\SAT$ (a decision problem) and the corresponding search problem $\SAT$-search which asks for an assignment. 

\begin{theorem}
$\SAT \in \P \implies \mathsf{SAT-SEARCH}$ is poly-time.
\end{theorem}
\begin{proof}
Surprisingly intuitive! Image a $\SAT$ instance $\phi(x_1, ..., x_n)$ that you want to find an assignment for. Randomly assign $x_1 = 1$ and ask the polynomial $\SAT$ for the decidability of $\phi(1, ..., x_n)$. If it says yes, then proceed on and randomly assign $x_2$. Otherwise assign $x_1 = 0$ and randomly assign $x_2$.
\end{proof}

Suppose that we are given that $\SAT \in \Time (n^c)$ then we can actually find an explicit $\SAT$ algorithm that runs in $O(n^{2+c})$.

\begin{theorem}
(Levin's Universal Search) Suppose $\SAT \in \Time(n^c)$ for a known constant $c > 0$ for some black box algorithm. Then there exists an explicit polytime algorithm that solves $\SAT$ in time $O(n^{c+2}\cdot \log^2 n + t_0(n)\cdot n)$, where $t_0(n) \in \mathsf{poly}(n)$ is the time needed to check if a given assignment satisfies a specified $\SAT$ instance of size $n$.   
\end{theorem}
\begin{proof}
$\SAT$-search is solved in $O(n^{c+1})$ by the above algorithm and using the black-box. The explicit algorithm to solve $\SAT$ takes input $\phi$ of size $n$ and loops from $1$ to $n$ as follows: simulate TM $M_i$ on $\phi$ for $O(n^{c+1}\cdot \log^2 n)$ steps. If $M_i$ produces a satisfying assignment for $\phi$ except and halt. If the loop terminates and no satisfying assignment was found, reject. Why does this work? \textcolor{red}{Think about it!}
\end{proof}

\section{Introduction to Polynomial Hierarchy}

Polynomial hierarchy $\PH$ is the generalization of the classes $\P, \NP$, and $\coNP$. There are an infinite number of subclasses in $\PH$ which are conjectured to be distinct (stronger version of $\P \neq \NP$. Three definitions of $\PH$ are as follows:
\begin{enumerate}
\item defined as the set of languages defined via polynomial-time predicates combined with a constant number of alternating for all and exists quantifiers, generalizing the definitions of $\NP$ and $\coNP$. 
\item defined in-terms \textbf{alternating TM} which generalize NTM.
\item defined using \textbf{oracle TM}.
\end{enumerate}

\begin{theorem}
(Fortnow) $\SAT \notin \mathsf{TimeSpace} (n^{1.1}, n^{0.1})$. This means you have $O(n^{1.1})$ time and $O(n^{0.1})$ space, then you definitely cannot solve $\SAT$.
\end{theorem}

We will use the following two ideas: (1) $\NTime$-Hierarchy and (2) Poly Hierarchy (alternation). Before we begin the proof we need some tools. 

First (2) denoted by $\PH$. Note $\NP, \coNP \subset \PH$, where $\NP = \exists \bar{x}: \phi(x_1, ..., x_n)$ and $\coNP = \forall \bar{x}: \phi (x_1, ..., x_n)$, since $\PH$ is the set of first order logical statements with any number alternating $\forall$ and $\exists$. 

Let a $k$-ary relation $R$ be \textbf{polynomially balanced} if, for every tuple $(a_1, ..., a_k) \in R$, the lengths of all $a_i$'s are polynomially related to each other.

\begin{definition}
For any $i\geq 1$, a language $L \in \sum_{i}^{p}$ iff there is a polynomially balanced $(i+1)$-ary relation $R$ such that 
\[L = \{x: \exists y_1\forall y_2 \exists y_3 \cdots Q_iy_iR(x, y_1, ..., y_i)\}\]
where $Q_i \in \{\forall, \exists\}$ depending on the parity of $i$. 
\end{definition}

\begin{definition}
For any $i\geq 1$, a language $L \in \prod_{i}^{p}$ iff there is a polynomially balanced $(i+1)$-ary relation $R$ such that 
\[L = \{x: \forall y_1\exists y_2 \forall y_3 \cdots Q_iy_iR(x, y_1, ..., y_i)\}\]
where $Q_i \in \{\forall, \exists\}$ depending on the parity of $i$. 
\end{definition}

Remark that $\NP \in \sum_{1}^{p}$ and $\coNP \in \prod_{1}^{p}$. In general $\prod_{i}^{p} =\mathsf{co}\sum_{i}^{p}$. $\PH = \cup_{i\geq 0}\sum_{i}^{p}$. Examples of $\PH$ include: $\mathsf{UNIQUE-SAT} \in \sum_{2}^{p}$, $\mathsf{MIN-CIRCUIT} \in \prod_{2}^{p}$. 
\begin{theorem}
$\PH \subseteq \PSPACE$
\end{theorem}
\begin{proof}

\end{proof}

Another definition of $\PH$ does things recursively: $\sum_{0}^{p} = \prod_{0}^{p} = \P$. For all $i \geq 0$ define $\sum_{i}^{p} = \NP^{\prod_{i-1}^{p}}$ and $\prod_{i}^{p} = \coNP^{\sum_{i-1}^{p}}$.

\begin{theorem}
This alternate definition is same as the previous one. 
\end{theorem}
\begin{proof}
By induction on $i$. 
\end{proof}

Another definition is in-terms of Oracle TM. This TM has a special \emph{oracle tape}. By entering a special state $q?$. In one time step you will end up in $q_{yes}$ or $q_{no}$ depending on what you put on the oracle tape as input. Consider the following: clearly $\SAT \in \P^{\SAT}$. Can you see why $\mathsf{UNIQUE-SAT} \in \NP^{\SAT}$? How about $\mathsf{UNIQUE-SAT} \in \P^{\SAT}$? \emph{Here is the hint for the second question: you need to use the idea from $\mathsf{SEARCH-SAT}$ and the idea from the previous question.}

The definition of $\PH$ in-terms the Oracle TM is then:

\begin{theorem}
Again, this alternate definition is equivalent to the original definition.
\end{theorem} 

\begin{proof}
(Fortnow).
\end{proof}
\end{document}