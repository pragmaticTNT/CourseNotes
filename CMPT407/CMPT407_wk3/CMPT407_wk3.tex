%
% This is a borrowed LaTeX template file for lecture notes for CS267,
% Applications of Parallel Computing, UCBerkeley EECS Department.
% Now being used for CMU's 10725 Fall 2012 Optimization course
% taught by Geoff Gordon and Ryan Tibshirani.  When preparing 
% LaTeX notes for this class, please use this template.
%
% To familiarize yourself with this template, the body contains
% some examples of its use.  Look them over.  Then you can
% run LaTeX on this file.  After you have LaTeXed this file then
% you can look over the result either by printing it out with
% dvips or using xdvi. "pdflatex template.tex" should also work.
%

\documentclass[twoside]{article}
\setlength{\oddsidemargin}{0.25 in}
\setlength{\evensidemargin}{-0.25 in}
\setlength{\topmargin}{-0.6 in}
\setlength{\textwidth}{6.5 in}
\setlength{\textheight}{8.5 in}
\setlength{\headsep}{0.75 in}
\setlength{\parindent}{0 in}
\setlength{\parskip}{0.1 in}

%
% ADD PACKAGES here:
%

\usepackage{amsmath,amsfonts,amssymb, graphicx}
\usepackage{color}
\usepackage{comment}
\usepackage{mathtools}

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}

%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[4]{
   \pagestyle{myheadings}
   \thispagestyle{plain}
   \newpage
   \setcounter{lecnum}{#1}
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CMPT 407: Computational Complexity
	\hfill Summer 2017} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill Lecture #1: #2  \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Lecturer: #3 \hfill Scribe: #4} }
      \vspace{2mm}}
   }
   \end{center}
   \markboth{Lecture #1: #2}{Lecture #1: #2}

   %{\bf Note}: {\it LaTeX template courtesy of UC Berkeley EECS dept.}

   %{\bf Disclaimer}: {\it These notes have not been subjected to the
   %usual scrutiny reserved for formal publications.  They may be distributed
   %outside this class only with the permission of the Instructor.}
   \vspace*{4mm}
}
%
% Convention for citations is authors' initials followed by the year.
% For example, to cite a paper by Leighton and Maggs you would type
% \cite{LM89}, and to cite a paper by Strassen you would type \cite{S69}.
% (To avoid bibliography problems, for now we redefine the \cite command.)
% Also commands that create a suitable format for the reference list.
%\renewcommand{\citep{â€¢}ite}[1]{[#1]}
\def\beginrefs{\begin{list}%
        {[\arabic{equation}]}{\usecounter{equation}
         \setlength{\leftmargin}{2.0truecm}\setlength{\labelsep}{0.4truecm}%
         \setlength{\labelwidth}{1.6truecm}}}
\def\endrefs{\end{list}}
\def\bibentry#1{\item[\hbox{[#1]}]}

%Use this command for a figure; it puts a figure in wherever you want it.
%usage: \fig{NUMBER}{SPACE-IN-INCHES}{CAPTION}
\newcommand{\fig}[3]{
			\vspace{#2}
			\begin{center}
			Figure \thelecnum.#1:~#3
			\end{center}
	}
% Use these for theorems, lemmas, proofs, etc.
\newtheorem{theorem}{Theorem}[lecnum]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{2mm}{2mm}}

% **** IF YOU WANT TO DEFINE ADDITIONAL MACROS FOR YOURSELF, PUT THEM HERE:

\newcommand\E{\mathbb{E}}
\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\R{\mathbb{R}}
\def\C{\mathbb{C}}
\def\F{\mathbb{F}}
\def\P{\mathsf{P}}
\def\NP{\mathsf{NP}}
\def\coNP{\mathsf{coNP}}
\def\PH{\mathsf{PH}}
\def\EXP{\mathsf{EXP}}
\def\NEXP{\mathsf{NEXP}}
\def\Time{\mathsf{Time}}
\def\SAT{\mathsf{SAT}}
\def\SIZE{\mathsf{SIZE}}
\def\TAUT{\mathsf{TAUT}}
\def\NTime{\mathsf{NTime}}
\def\PSPACE{\mathsf{PSPACE}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\anglebrac{\langle}{\rangle}

\begin{document}
%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
\lecture{2}{Poly-time Hierarchy - 23~26 May}{Valentine Kabanets}{Lily Li}
%\footnotetext{These notes are partially based on those of Nigel Mansell.}

\section{Space Hierarchy}
Similar to the Time Hierarchy theorems, it simply states that with more time we can do more work. 

\begin{theorem}
For any $n \leq s \leq S \leq 2^n/n$ such that $S \geq 10 \cdot s$, we have
\[\SIZE (s) \subsetneq \SIZE (S)\]
\end{theorem}
\begin{proof}
First we will prove the following:
\begin{theorem}
(Shannon-Lupanov) For all sufficiently large $n$, the maximum circuit complexity of an $n$-variate Boolean function is
\[\frac{2^n}{n}\left( 1 + \Theta\left( \frac{\log n}{n}\right)\right)\]
\end{theorem}

\textcolor{red}{More of the proof to come...}
\end{proof}

We see this using a counting argument. Consider the total number of boolean formulas: there are $2^n$ possible clauses and each clause could be in the formula so there are $2^{2^n}$ boolean formulas. 	

\section{$\SAT$ Menagerie}
Consider different types of $\SAT$: 
\begin{enumerate}
\item Circuit $\SAT$ - these look like general digraph.
\item Formula $\SAT$ - these look like trees (only one output from each node).
\item CNF $\SAT$ - we have a CNF formula. 
\item $k-\SAT$ - each clause in the CNF has at most $k-\SAT$
\end{enumerate}

\begin{theorem}
All the above (including the last one with $k \geq 3$) are $\NP$-complete. 
\end{theorem}
\begin{proof}
We already showed that Circuit-$\SAT$ is $\NP$-complete. Next we will show that $3-\SAT$ is $\NP$-complete to complete the proof. It should be easy to see that $\SAT$ is in $\NP$. To show that $\SAT$ is $\NP$-hard reduce Circuit-$\SAT$ to $3-\SAT$. Take a circuit $C(x_1, ..., x_n)$ as an input. We want to make an instance of $3-\SAT$ associated with $C$. Let $\phi (x_1, ..., x_{n^d})$ be our $3-\SAT$ instance. Label the gates of $C$ as $g_1, ..., g_m$. Associate to each gate a set of $3$-CNF clauses. Then conjunct all the clauses (don't forget the output gate). Yay! You have created a valid $3-\SAT$ instance.    
\end{proof}

Consider the following trivial $\NP$-complete language:
\[L_u = \{ (M, x, 1^k): NTM M \mbox{ accepts } x \mbox{ in } \leq k \mbox{ steps}\}\]
\begin{proposition}
$L_u$ is $\NP$-complete.
\end{proposition}
\begin{proof}

\end{proof}

Once $\SAT$ was proved $\NP$-complete many more were proved to be $\NP$-complete as well. Such as $\mathsf{NAE-SAT}$ (not all equal $\SAT$) as follows: (omitting proof that $\mathsf{NAE-SAT} \in \NP$) 

Other language of interest is $\coNP$. Where languages in $\NP$ are those which have easy to verify $yes$ instances $\coNP$ have easy to verify $no$ instances. Not that $\NP$ and $\coNP$ are \emph{NOT} disjoint since $\P$ is in both. It is unknown if $\coNP = \NP$. 

\begin{proposition}
$\TAUT$ is $\coNP$-complete
\end{proposition}
\begin{proof}

\end{proof}

\section{Introduction to Polynomial Hierarchy}

Polynomial hierarchy $\PH$ is the generalization of the classes $\P, \NP$, and $\coNP$. There are an infinite number of subclasses in $\PH$ which are conjectured to be distinct (stronger version of $\P \neq \NP$. Three definitions of $\PH$ are as follows:
\begin{enumerate}
\item defined as the set of languages defined via polynomial-time predicates combined with a constant number of alternating for all and exists quantifiers, generalizing the definitions of $\NP$ and $\coNP$. 
\item defined interms \textbf{alternating TM} which generalize NTM.
\item defined using \textbf{oracle TM}.
\end{enumerate}

\begin{theorem}
(Fortnow) $\SAT \notin \mathsf{TimeSpace} (n^{1.1}, n^{0.1})$. This means you have $O(n^{1.1})$ time and $O(n^{0.1})$ space, then you definitely cannot solve $\SAT$.
\end{theorem}
\begin{proof}
We will use the following two ideas: (1) $\NTime$-Hierarchy and (2) Poly Hierarchy (alternation). 

First (2) denoted by $\PH$. Note $\NP, \coNP \subset \PH$, where $\NP = \exists \bar{x}: \phi(x_1, ..., x_n)$ and $\coNP = \forall \bar{x}: \phi (x_1, ..., x_n)$, since $\PH$ is the set of first order logical statements with any number alternating $\forall$ and $\exists$. 
\end{proof} 

\section{Nondeterministic Time Hierarchy}
Much like deterministic time hierarchy and space hierarchy, we need some way to say that with more time on a nondeterministic machine we can do more work. This is formalized in the following theorem. However, this time our standard diagonalization trick will not work because it is not know if $\NP = \coNP$.

\begin{theorem}
\textbf{$\NTime$ Hierarchy Theorem} For every proper complexity function $f(n) \geq n$ and $g(n) \in \omega(f(n+1))$, we have
\[\NTime (f(n)) \subsetneq \NTime (g(n))\]
\end{theorem} 
\begin{proof}
This is requires a different tool than diagonalization. The difficulty is due to the lack of closure for complementation in $\NP$ (not known if $\coNP = \NP$). Enumerate all NTM $M_1, M_2, ...$ which are clocked to run in less than $f(n)$ steps over the unary alphabet (this strengthens the theorem). Let $L(M_i)$ be the language of machine $M_i$. Let $t(n)$ be a fast growing function split the natural numbers into intervals $[1, ..., t(n)], [t(n) + 1, ..., t^{(2)}(n)], ...$ indexed $I_1, I_2, ...$ where interval $I_i = [t^{i-1}(n), ..., t^{i}(n)]$ where $t^{k}(n)$ is the composition of $t(n)$, $k$ times. Define NTM $D$ which diagonalizes all $M_i$.  
\end{proof}

\section{Decision to Search}
Consider the difference between $\SAT$ (a decision problem) and the corresponding search problem $\SAT$-search which asks for an assignment. 

\begin{theorem}
$\SAT \in \P \implies \mathsf{SAT-SEARCH}$ is poly-time.
\end{theorem}
\begin{proof}
Surprisingly intuitive! Image a $\SAT$ instance $\phi(x_1, ..., x_n)$ that you want to find an assignment for. Randomly assign $x_1 = 1$ and ask the polynomial $\SAT$ for the decidability of $\phi(1, ..., x_n)$.
\end{proof}

Suppose that we are given that $\SAT \in \Time (n^c)$ then we can actually find an explicit $\SAT$ algorithm that runs in $O(n^{2+c})$.

\section{Polynomial Hierarchy}
\begin{definition}
For $i \geq 1$, a language $L$ is in $\sup^P_2$ if there exists a polynomial-time TM $M$ and a polynomial $q$ such that
\[x \in L \iff \exists u_1\in \{0,1\}^{q(|x|)} \forall u_2 \in 
\{0, 1\}^{q(|x|)} \cdots Q_i u_i \in \{0,1\}^{q(|x|)} M(x, u_1, ..., u_i) = 1\]
where $Q_i$ is a $\forall$ or a $\exists$ depending if $i$ is even or odd. \textbf{Polynomial hierarchy (PH)} is $\PH = \cup_{i} \sum^P_2$.
\end{definition}

\emph{The polynomial hierarchy does not collapse.}

\begin{theorem}
The following hold:
\begin{enumerate}
\item For every $i \geq 1$, if $\sum^P_i = \prod^P_i$ then $\PH = \sum^P_i$ i.e. the hierarchy collapses to the $i$th level.
\item If $\P = \NP$ then $PH = P$ i.e. the hierarchy collapses to $\P$. 
\end{enumerate}
\end{theorem}

\begin{proposition}
$\PH \subseteq \PSPACE$.
\end{proposition}
\begin{proof}

\end{proof}
\end{document}